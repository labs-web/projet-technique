# Architecture d'un SKILL Multi-Technologique

## Introduction

Ce document définit l'architecture de référence pour concevoir un SKILL Antigravity qui manipule plusieurs technologies. Il établit les principes de structuration, la séparation des responsabilités, et l'organisation des ressources documentaires.

---

## Définition Fondamentale : Qu'est-ce qu'un SKILL ?

### Nature et Objectif

Un SKILL est une **unité d'expertise fonctionnelle** qui encapsule :

- **Un Rôle Métier Précis** : Ce que l'agent produit (exemple : "créer la couche HTTP de l'API")
- **Un Algorithme d'Exécution** : Les étapes séquentielles pour accomplir le rôle
- **Des Contraintes Techniques** : Les règles, standards et garde-fous à respecter
- **Des Critères de Validation** : Les points de contrôle pour garantir la qualité

### Ce qu'un SKILL N'EST PAS

**INTERDICTION** de confondre un SKILL avec :

- **Une Documentation Technique Exhaustive** : L'IA connaît déjà Laravel, Alpine, Tailwind. Le SKILL définit les standards projet, pas la syntaxe de base.
- **Un Tutoriel de Programmation** : Le SKILL impose des décisions, il n'enseigne pas comment coder.
- **Une Base de Connaissances Générique** : Le SKILL est contextuel au projet, pas un wiki universel.
- **Un Catalogue de Code** : Le SKILL définit les règles, pas des snippets réutilisables.

### Principe Directeur : "Directives, pas Documentation"

L'IA possède déjà une connaissance générale des technologies. Le SKILL lui apporte :

- **Le "QUOI"** : Quelles actions effectuer dans quel ordre
- **Le "POURQUOI"** : Les raisons des choix architecturaux
- **Le "COMMENT DÉCIDER"** : Les critères de décision en cas d'ambiguïté
- **Le "INTERDIT"** : Les pratiques à bannir absolument

---

## Principes d'Organisation Multi-Technologique

### Principe 1 : Granularité Fonctionnelle vs Technique

**Choix Architectural :**

Les SKILLS sont organisés par **rôle fonctionnel** (ce qu'on produit) et non par **technologie utilisée**.

**Exemple : SKILL `backend-http`**

- **Rôle** : Créer la couche HTTP de l'API (Routes, Contrôleurs, FormRequests, API Resources)
- **Technologies utilisées** : Laravel, PHP, PSR-12, Sanctum
- **Logique** : Un développeur backend HTTP maîtrise naturellement Laravel pour son domaine

**Contre-exemple à éviter : SKILL `expert-laravel`**

- **Rôle** : Fournir toute la connaissance Laravel
- **Problème** : Trop générique, pas d'ancrage fonctionnel, redondant avec la connaissance de base de l'IA

### Principe 2 : Technologies Interdépendantes Regroupées

Lorsque plusieurs technologies forment un **tout cohérent**, les documenter ensemble.

**Exemple : Tailwind + Preline UI + Alpine.js**

Ces trois technologies sont souvent configurées et utilisées ensemble dans le frontend. Plutôt que trois fichiers séparés, créer un fichier `frontend-stack.md` qui explique leur orchestration.

### Principe 3 : Séparation Vue Globale / Détails Techniques

**Architecture en deux niveaux :**

1. **SKILL.md** : Orchestration, workflow, décisions de haut niveau
2. **resources/** : Spécifications détaillées, contraintes techniques, références

---

## Architecture Type d'un SKILL Multi-Technologique

### Structure des Dossiers et Fichiers

```
.agent/skills/[nom-du-skill]/
├── SKILL.md                          # Orchestration et workflow principal
├── resources/
│   ├── 0-specifications.md           # Vue d'ensemble stratégique
│   ├── 1-phase-[nom].md              # Détails d'une phase d'exécution
│   ├── 2-phase-[nom].md              # Autre phase
│   ├── ...
│   └── 9-validation.md               # Critères de succès
└── templates/                        # (Optionnel) Modèles de fichiers
    ├── example-controller.php.stub
    └── example-migration.php.stub
```

### Convention de Nommage

**Fichiers resources/ :**

- **Préfixe numérique** : `0-`, `1-`, `2-`, ..., `9-` pour imposer l'ordre logique
- **Nom explicite** : Décrit le contenu fonctionnel, pas la technologie seule
- **Séparation par phase** : Un fichier par étape majeure du workflow

**Exemples :**

- ✅ `1-backend-setup.md` (phase fonctionnelle)
- ✅ `2-frontend-stack.md` (groupe de technologies)
- ❌ `laravel.md` (trop générique)
- ❌ `step1.md` (nom non explicite)

---

## Contenu de Chaque Composant

### Le Fichier Principal : `SKILL.md`

**Rôle :** Définir l'identité du SKILL, orchestrer l'exécution, et pointer vers les ressources détaillées.

**Structure Obligatoire :**

```
---
name: nom-du-skill
description: Description concise du rôle (une ligne)
---

# Skill : [Nom Complet]

## Rôle et Périmètre
- Définition claire de la responsabilité fonctionnelle
- Délimitation des frontières (ce que le skill NE fait PAS)

## Inputs / Outputs
- Inputs : Fichiers, informations, états requis avant exécution
- Outputs : Livrables produits par le skill

## Algorithme d'Exécution
- Étapes séquentielles numérotées
- Références explicites vers les fichiers resources/
- Points de validation (STOP DÉVELOPPEUR)

## Standards Requis
- Conventions de nommage
- Règles de formatage
- Exigences de sécurité

## Interdictions
- Actions strictement interdites
- Justification de chaque interdiction
```

**Contenu du Fichier :**

- **Stratégique** : Vue d'ensemble du workflow
- **Décisionnel** : Quand consulter quelle ressource
- **Concis** : 50-150 lignes maximum
- **Sans Détail Technique** : Déléguer aux fichiers resources/

**Exemple de Section Algorithme :**

```
## Algorithme d'Exécution

### Phase 0 : Préparation
1. Lire `resources/0-specifications.md` → Vue d'ensemble des contraintes
2. Identifier les technologies requises pour la fonctionnalité

### Phase 1 : Configuration Backend
1. Suivre `resources/1-backend-setup.md`
2. Appliquer les contraintes de sécurité définies
3. **STOP DÉVELOPPEUR** : Valider la configuration avec les critères définis

### Phase 2 : Configuration Frontend
1. Suivre `resources/2-frontend-stack.md`
2. Vérifier la cohérence avec les composants UI-Kit
3. **STOP DÉVELOPPEUR** : Tester le rendu sur mobile et desktop
```

---

### Fichier de Vue Globale : `0-specifications.md`

**Rôle :** Centraliser les informations stratégiques et transverses.

**Contenu Typique :**

**Vue d'Ensemble :**
- Contexte fonctionnel (pourquoi ce skill existe)
- Liste des technologies utilisées avec leurs versions

**Contraintes Transverses :**
- Compatibilité entre technologies (exemple : Laravel 11 nécessite PHP 8.2+)
- Ordre d'installation obligatoire
- Dépendances critiques

**Matrice de Décision :**
- Quand utiliser la technologie A vs technologie B
- Critères de choix selon le contexte

**Glossaire :**
- Termes techniques spécifiques au projet
- Définition des concepts métier

**Exemple de Structure :**

```
# Spécifications Générales

## Contexte Fonctionnel
Description de la mission du skill dans le projet global.

## Technologies Utilisées
- Technologie A : Version X.Y (Rôle dans le skill)
- Technologie B : Version X.Y (Rôle dans le skill)

## Contraintes de Compatibilité
- Technologie A nécessite Technologie C >= version X
- Installation obligatoire dans l'ordre : A → B → C

## Matrice de Décision
### Choix entre Technologie A et B
- Utiliser A si : Critère 1
- Utiliser B si : Critère 2

## Interdictions Transverses
- INTERDICTION d'utiliser Technologie X (raison : incompatibilité)
```

---

### Fichiers de Phase : `1-phase-[nom].md`, `2-phase-[nom].md`

**Rôle :** Documenter en détail une étape majeure du workflow.

**Critères de Découpage :**

Un fichier de phase doit correspondre à :
- **Une Étape Fonctionnelle Cohérente** : Installation, Configuration, Implémentation, Validation
- **Un Ensemble de Technologies Interdépendantes** : Tailwind + Preline configurés ensemble
- **Un Livrable Identifiable** : À la fin de la phase, quelque chose de concret existe

**Contenu Typique :**

**Objectif de la Phase :**
- Résultat attendu à la fin de l'exécution

**Prérequis :**
- Phases précédentes complétées
- Fichiers ou états nécessaires

**Technologies Impliquées :**
- Liste des technologies manipulées dans cette phase

**Actions à Effectuer :**
- Liste séquentielle des opérations (sans code exhaustif)
- Commandes critiques à exécuter
- Fichiers à créer ou modifier

**Contraintes et Standards :**
- Règles spécifiques à cette phase
- Conventions de nommage
- Bonnes pratiques

**Points de Contrôle :**
- Critères de validation pour passer à la phase suivante
- Commandes de vérification
- Résultats attendus

**Exemple de Structure :**

```
# Phase 1 : Configuration Backend

## Objectif
Mettre en place la structure backend avec Laravel et configurer les outils de qualité.

## Prérequis
- Environnement PHP 8.2+ installé
- Composer disponible

## Technologies de la Phase
- Laravel 11.x
- Laravel Pint 1.x

## Actions

### Étape 1.1 : Installation Laravel
- Créer le projet Laravel dans le répertoire courant
- Copier le fichier d'environnement
- Générer la clé applicative

### Étape 1.2 : Configuration de Base
- Configurer la connexion base de données
- Définir le fuseau horaire
- Activer le mode debug

### Étape 1.3 : Installation des Outils Qualité
- Installer Laravel Pint via Composer
- Configurer les règles PSR-12

## Contraintes

### Nommage
- Variables et fonctions : Anglais
- Commits Git : Français

### Sécurité
- Ne jamais commiter le fichier .env

## Points de Contrôle
- Vérifier la version de Laravel installée
- Tester le serveur de développement
- Valider que Pint s'exécute sans erreur
```

---

### Fichier de Validation : `9-validation.md`

**Rôle :** Centraliser tous les critères de succès du skill.

**Contenu Typique :**

**Checklist Fonctionnelle :**
- Liste des livrables produits et leur état attendu

**Checklist Technique :**
- Conformité aux standards de code
- Respect des contraintes de sécurité
- Performance acceptable

**Tests Manuels :**
- Scénarios à exécuter pour valider le fonctionnement

**Tests Automatisés :**
- Commandes à exécuter (linters, tests unitaires)

**Exemple de Structure :**

```
# Validation du Skill

## Livrables Attendus

### Fichiers Backend
- Migrations créées et exécutées
- Modèles Eloquent avec relations définies
- Seeders opérationnels

### Fichiers Frontend
- Composants Blade réutilisables
- Scripts JS compilés sans erreur
- Styles CSS conformes au UI-Kit

## Standards de Qualité

### Code
- PSR-12 respecté (vérifier avec Pint)
- Typage strict activé
- Commentaires en français pour logique complexe

### Sécurité
- Pas de requêtes SQL concaténées
- Variables échappées dans Blade
- Tokens CSRF présents dans les formulaires

## Tests Fonctionnels

### Scénarios à Valider
- Scénario 1 : Description du flux utilisateur à tester
- Scénario 2 : Autre flux critique

### Commandes de Vérification
- Commande 1 : Résultat attendu
- Commande 2 : Résultat attendu

## Critères de Succès Global

Le skill est validé si et seulement si :
- Tous les livrables sont présents
- Toutes les checklists sont cochées
- Tous les tests passent
```

---

## Règles de Gestion du Contenu

### Règle 1 : Éviter la Redondance

**INTERDICTION** de dupliquer l'information entre :
- `SKILL.md` et les fichiers `resources/`
- Plusieurs fichiers `resources/`

**Solution :**
- `SKILL.md` → Référence les fichiers resources
- Chaque information n'existe qu'à un seul endroit

### Règle 2 : Priorité aux Contraintes sur l'Enseignement

Un fichier resource doit répondre à :

**✅ Questions Prescriptives :**
- "Quelle version utiliser ?"
- "Dans quel ordre installer ?"
- "Quelle convention de nommage appliquer ?"
- "Quelles pratiques sont interdites ?"

**❌ Questions Descriptives :**
- "Comment fonctionne Laravel ?"
- "Qu'est-ce qu'une migration ?"
- "Quelle est la syntaxe de Alpine.js ?"

### Règle 3 : Séparation Stratégique / Opérationnel

**Fichier `0-specifications.md` :**
- Vue stratégique
- Matrice de compatibilité
- Décisions architecturales

**Fichiers de phase :**
- Exécution opérationnelle
- Commandes concrètes
- Validation immédiate

### Règle 4 : Granularité Adaptée

**Un fichier par phase logique :**
- ✅ Trop granulaire : Un fichier par commande → Difficile à maintenir
- ✅ Optimal : Un fichier par étape majeure → Équilibre maintenance/lisibilité
- ✅ Trop coarse : Tout dans un fichier → Perte de structure

**Critères de découpage :**
- Un fichier = 50-200 lignes
- Un fichier = Une étape validable indépendamment
- Un fichier = Un ensemble cohérent d'actions

---

## Gestion des Technologies Multiples

### Approche 1 : Technologies Séquentielles

**Contexte :** Les technologies s'installent l'une après l'autre sans interaction forte.

**Architecture :**

```
resources/
├── 1-technologie-a.md
├── 2-technologie-b.md
└── 3-technologie-c.md
```

**Exemple :** Laravel → ensuite → Pint → ensuite → Prettier (séquence linéaire)

### Approche 2 : Technologies Interdépendantes

**Contexte :** Les technologies forment un écosystème et se configurent ensemble.

**Architecture :**

```
resources/
├── 1-stack-frontend.md    # Tailwind + Preline + Alpine ensemble
└── 2-stack-backend.md     # Laravel + Sanctum + Pint ensemble
```

**Exemple :** Tailwind nécessite la configuration de Preline qui utilise Alpine → Un seul fichier

### Approche 3 : Hybride (Recommandée)

**Contexte :** Mélange de technologies séquentielles et interdépendantes.

**Architecture :**

```
resources/
├── 0-specifications.md      # Vue globale
├── 1-phase-technologie-a.md # Phase autonome
├── 2-phase-stack-xyz.md     # Phase avec technologies liées
└── 9-validation.md          # Validation globale
```

**Critère de Décision :**

Si technologies A et B sont configurées dans le même fichier (exemple : `tailwind.config.js` référence Preline) → Même fichier resource.

Si technologies A et B sont indépendantes → Fichiers séparés.

---

## Exemples d'Architecture selon le Type de SKILL

### Exemple 1 : SKILL d'Installation (`expert-stack-config`)

**Nature :** Orchestration de l'installation de plusieurs technologies.

**Architecture :**

```
expert-stack-config/
├── SKILL.md
├── resources/
│   ├── 0-specs-stack.md              # Versions, compatibilité
│   ├── 1-laravel-install.md          # Backend seul
│   ├── 2-frontend-stack.md           # Tailwind + Preline + Alpine
│   ├── 3-quality-tools.md            # Pint + Prettier
│   └── 9-validation-finale.md        # Tests de l'ensemble
```

**Logique :** Découpage par phase d'installation (backend → frontend → qualité).

### Exemple 2 : SKILL de Développement (`dev-frontend-js`)

**Nature :** Production de code avec plusieurs technologies.

**Architecture :**

```
dev-frontend-js/
├── SKILL.md
├── resources/
│   ├── 0-specs-frontend.md           # Comportements attendus
│   ├── 1-blade-integration.md        # Transformation HTML → Blade
│   ├── 2-alpine-patterns.md          # Patterns Alpine.js
│   ├── 3-ajax-fetch.md               # Communication API
│   └── 9-validation-checklist.md     # Critères de succès
```

**Logique :** Découpage par type d'activité (intégration → interactivité → communication).

### Exemple 3 : SKILL de Configuration (`backend-data`)

**Nature :** Création de la couche de données.

**Architecture :**

```
backend-data/
├── SKILL.md
├── resources/
│   ├── 0-specs-data.md               # Schéma de la base
│   ├── 1-migrations.md               # Standards migrations
│   ├── 2-models.md                   # Standards modèles Eloquent
│   ├── 3-factories-seeders.md        # Données de test
│   └── 9-validation.md               # Vérifications
```

**Logique :** Découpage par type de livrable (migrations → modèles → seeders).

---

## Anti-Patterns à Éviter

### Anti-Pattern 1 : Le SKILL Encyclopédie

**Symptôme :**
- Fichiers resources/ contiennent toute la documentation officielle de Laravel, Tailwind, etc.
- Taille totale du skill > 500 lignes

**Conséquence :**
- Redondance avec la connaissance de base de l'IA
- Difficile à maintenir
- Dilue les contraintes réelles du projet

**Solution :**
- Ne documenter QUE les décisions spécifiques au projet
- Référencer la documentation officielle si nécessaire (lien externe)

### Anti-Pattern 2 : Le SKILL Atomique

**Symptôme :**
- Un SKILL par commande (exemple : `create-migration`, `run-migration`, `create-model`)
- Multiplication excessive des skills

**Conséquence :**
- Fragmentation de la logique
- Orchestration complexe
- Perte de vue d'ensemble

**Solution :**
- Regrouper les actions cohérentes dans un même skill
- Un skill = Un livrable fonctionnel

### Anti-Pattern 3 : Le SKILL Monolithique

**Symptôme :**
- Un seul fichier `SKILL.md` de 500+ lignes
- Aucun fichier resource
- Tout mélangé (stratégie + opérationnel + validation)

**Conséquence :**
- Difficile à naviguer
- Impossible de réutiliser des parties
- Maintenance cauchemardesque

**Solution :**
- Séparer SKILL.md (orchestration) et resources/ (détails)
- Découper par phase logique

### Anti-Pattern 4 : La Duplication Cross-Skills

**Symptôme :**
- Les mêmes standards de sécurité répétés dans 5 skills différents
- Divergence progressive (chaque skill a sa version)

**Conséquence :**
- Incohérence
- Maintenance multiplicative

**Solution :**
- Créer un SKILL transverse (exemple : `expert-security`)
- Référencer explicitement ce skill depuis les autres
- Maintenir une seule source de vérité

---

## Principe de Référencement Inter-Skills

### Appel Explicite dans l'Algorithme

Un SKILL peut demander à l'IA de consulter un autre SKILL pour une sous-tâche :

**Exemple dans `backend-http/SKILL.md` :**

```
## Algorithme d'Exécution

### Phase 2 : Implémentation des Policies
1. Si la fonctionnalité nécessite des autorisations complexes :
   - Consulter le skill `backend-business`
   - Appliquer les règles définies dans `backend-business/resources/policies.md`
2. Créer les Policies Laravel selon ces règles
```

### Fichier de Ressource Partagée

Pour les contraintes transverses (sécurité, qualité), centraliser dans un skill de référence :

**Architecture :**

```
.agent/skills/
├── expert-security/
│   ├── SKILL.md
│   └── resources/
│       ├── validation-rules.md
│       ├── authentication.md
│       └── xss-prevention.md
├── backend-http/         ← Consulte expert-security
└── dev-frontend-js/      ← Consulte expert-security
```

**Référencement dans `backend-http/SKILL.md` :**

```
## Standards de Sécurité

Pour toute validation de données utilisateur :
1. Consulter `expert-security/resources/validation-rules.md`
2. Appliquer les règles définies aux FormRequests Laravel
```

---

## Conclusion : Principes Directeurs d'un SKILL Multi-Technologique

### Les 7 Commandements

1. **Rôle Fonctionnel d'Abord** : Organiser par qu'est-ce qu'on produit, pas par quelle technologie on utilise
2. **Contraintes, pas Documentation** : Imposer des décisions, pas enseigner la syntaxe
3. **Séparation Stratégique/Opérationnel** : SKILL.md pour l'orchestration, resources/ pour les détails
4. **Un Fichier = Une Phase Logique** : Découpage cohérent et validable
5. **Technologies Interdépendantes Ensemble** : Regrouper ce qui se configure de concert
6. **Validation Obligatoire** : Toujours un fichier `9-validation.md`
7. **Éviter la Redondance** : Une information, un seul endroit

### Checklist de Qualité d'un SKILL

Un SKILL bien conçu doit permettre de répondre OUI à :

- Le nom du skill décrit-il un rôle fonctionnel clair ?
- L'algorithme d'exécution est-il séquentiel et compréhensible ?
- Les fichiers resources/ sont-ils découplés et cohérents ?
- Les contraintes techniques sont-elles explicites ?
- Les interdictions sont-elles justifiées ?
- Les critères de validation sont-ils mesurables ?
- Le skill est-il maintenable (taille raisonnable, pas de duplication) ?

---

**Auteur :** Antigravity avec validation développeur  
**Date :** 2026-02-08  
**Version :** 1.0  
**Statut :** Document de Référence
